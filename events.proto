syntax = "proto3";

option go_package = "github.com/nimona/go-nimona-events";

package events;

enum HeaderType {
    MESSAGE = 0;                   // Used for messages which are signed but opaque
    CONFIG = 1;                    // Used for messages which express the channel config
    CONFIG_UPDATE = 2;             // Used for transactions which update the channel config
    // ENDORSER_TRANSACTION = 3;      // Used by the SDK to submit endorser based transactions
    // ORDERER_TRANSACTION = 4;       // Used internally by the orderer for management
    // DELIVER_SEEK_INFO = 5;         // Used as the type for Envelope messages submitted to instruct the Deliver API to seek
    // CHAINCODE_PACKAGE = 6;         // Used for packaging chaincode artifacts for install
}

// This is finalized block structure to be shared among the orderer and peer
// Note that the BlockHeader chains to the previous BlockHeader, and the BlockData hash is embedded
// in the BlockHeader.  This makes it natural and obvious that the Data is included in the hash, but
// the Metadata is not.
message Block {
    BlockHeader header = 1;
    BlockData data = 2;
    // BlockMetadata metadata = 3;
}

// BlockHeader is the element of the block which forms the block chain
// The block header is hashed using the configured chain hashing algorithm
// over the ASN.1 encoding of the BlockHeader
message BlockHeader {
    // uint64 number = 1; // The position in the blockchain
    bytes previous_hash = 2; // The hash of the previous block header
    bytes data_hash = 3; // The hash of the BlockData, by MerkleTree
}

// message BlockMetadata {
//     repeated bytes metadata = 1;
// }

message BlockData {
    // repeated bytes data = 1;
    repeated Envelope data = 1;
}

// Envelope wraps a Payload with a signature so that the message may be authenticated
message Envelope {
    Payload payload = 1;

    // A signature by the creator specified in the Payload header
    bytes signature = 2;
}

// Payload is the message contents (and header to allow for signing)
message Payload {

    // Header is included to provide identity and prevent replay
    Header header = 1;

    // Data, the encoding of which is defined by the type in the header
    // bytes data = 2;
    oneof data {
        Event event = 2;
        Config config = 3;
        ConfigUpdate config_update = 4;
    }
}

message Event {
    int32 version = 1;
}

message Config {
    int32 version = 1;
}

message ConfigUpdate {
    int32 version = 1;
}

message Header {
    // bytes channel_header = 1;
    ChannelHeader channel_header = 1;
    // bytes signature_header = 2;
    SignatureHeader signature_header = 2;
}

// Header is a generic replay prevention and identity message to include in a signed payload
message ChannelHeader {
    // HeaderType type = 1; // Header types 0-10000 are reserved and defined by HeaderType

    // Version indicates message protocol version
    int32 version = 2;

    // Timestamp is the local time when the message was created
    // by the sender
    // google.protobuf.Timestamp timestamp = 3;

    // Identifier of the channel this message is bound for
    string channel_id = 4;

    // An unique identifier that is used end-to-end.
    //  -  set by higher layers such as end user or SDK
    //  -  passed to the endorser (which will check for uniqueness)
    //  -  as the header is passed along unchanged, it will be
    //     be retrieved by the committer (uniqueness check here as well)
    //  -  to be stored in the ledger
    // string tx_id = 5;

    // The epoch in which this header was generated, where epoch is defined based on block height
    // Epoch in which the response has been generated. This field identifies a
    // logical window of time. A proposal response is accepted by a peer only if
    // two conditions hold:
    // 1. the epoch specified in the message is the current epoch
    // 2. this message has been only seen once during this epoch (i.e. it hasn't
    //    been replayed)
    // uint64 epoch = 6;

    // Extension that may be attached based on the header type
    // bytes extension = 7;
}

message SignatureHeader {
    // Creator of the message, specified as a certificate chain
    bytes creator = 1;

    // Arbitrary number that may only be used once. Can be used to detect replay attacks.
    bytes nonce = 2;
}

// SignaturePolicyEnvelope wraps a SignaturePolicy and includes a version for future enhancements
message SignaturePolicyEnvelope {
    int32 version = 1;
    SignaturePolicy policy = 2;
    repeated MSPPrincipal identities = 3;
}